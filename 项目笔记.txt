
跨域是浏览器为了安全而做出的限制策略
浏览器请求必须遵循同源策略：同域名、同端口、同协议
前端常见跨域的解决方案
CORS、JSONP、代理
CORS是服务器设置前端直接调用
跨域cookie是传不过去的这时候可以设置Access-Control-Allow-Credentials为true
JSONP：前端后端都需要改动
jsonp不是一个请求，封装了一个callback函数，axios
接口代理：通过修改nginx服务器配置来实现，前端修改，后端不动
本来是自己的接口
注意vue配置文件在启动前就已经保存，所以如果更改需要重新启动
assets放一些小图片
public放一些大图片
cnpm i vue-lazyload element-ui node-sass sass-loader vue-awesome-swiper vue-axios vue-cookie --save
组件是按名字加载的


Storage 封装
存储大小：cookie 其中userId是浏览器发给服务器的，JSESSIONID是服务器返回给浏览器的 4K storage5M
有效期：cookie拥有有效期，比如用户登录7天失效，storage永久存储
cookie会发送到服务器，存储在内存中，而storage只存储在浏览器中
路径：cookie有路径限制，storage不管哪个路径都可以存在域名中
API：cookie没有特定的API，storage有API
为什么要封装Storage
storage本身有API，但是只是简单的键值对
storage只存储字符串，需要人工转化为json对象
storage只能一次性清空，不能单个清空

接口错误拦截
统一报错
给用户报错
未登录统一拦截
请求值、返回值统一处理
axios中get有params但是post无
同时发多个请求加.all
vue-axios的作用是解决避免多次引入axios

设计思路
1.当拿到设计稿时首先确定有多少页面，每个页面是一个路由，在路由中找出公共部分，即为父组件，还要看是否有id值，

2.设置安全距离，最小宽度
防止网站压缩变形

3.设计样式可以分析将颜色字体抽离出来

复习transition transform 
a标签里是可以装块级元素，需要设置inline-block,撑满子元素
window.open和a标签的跳转类似

vue过滤器filter使用用于金额或者日期
动态路由
从a路由跳到b路由用router.push
取参用router.query或者router.params

页脚设计总结
先把公有样式（比如高度，边距，背景，布局，颜色，字体大小，是否居中显示）设置完成，然后是内部标签，
servicebar为啥不放在home原因是只有index等两个页面有
文字和线的高度一样可以设置border，除这以外还可以设置伪类的方式，还有直接使用|（页脚使用）
设置每个li的宽度不是25%的原因是浏览器的兼容问题
vertical-align可以使文字与图片在同一高度
起类名不能与组件名一致
问题vbind没有用key
问题swiper插件安装报错没有依赖，直接在官方github导入

透明度的问题，如果希望字体颜色不变就需要在背景图片上设置透明度而不是opacity
绝对定位和相对定位的混合使用不一定是父子关系有可能是兄弟关系
显示与隐藏元素用display：none和block切换

行内元素无法设置背景颜色

设计布局一定是从结构再到具体细节

splice和slice的区别
slice表示截取，slice(start,end)，不改变原数组，返回新数组。 splice表示删除，splice(start,length,item)，会改变原数组，从某个位置开始删除多个元素，并可以插入新的元素。
模态框制作
v-show可否放在index里
答案是可以，但是为了保证动画不失效，还是放在组件内部较好

插槽的使用首先是定义slot
然后在外部使用template v-slot

如何把一个弹框水平垂直居中
1.margintop，left设置为负一半
2.transform

组件不能使用click只能用自定义事件
问题transition进入没动画，离开有动画效果
解决查看官方文档，发现顺序不对把enter-active放在enter的上面,之后发现选择器名写错了，重改

懒加载的目的：提高首屏的加载速度
vuex当数据有延迟时使用计算属性
什么时候存在延迟呢
data数据没有请求时间，直接渲染，而接口调用是需要花时间的

vuex整理
先定义状态username，cartCount，当登录时会需要用dispatch派发给action，也可以用mapActions进行简写，到action时通过commit触发mutation,在mutation中直接给状态赋值，赋值完为了防止页面刷新完，用户名不显示信息，又拉取一次信息再派发一次，头部组件只负责渲染，通过属性状态直接获取，但是由于接口有延迟，接口的读取比渲染慢很多，所以使用计算属性来读取，为了简写，可以用mapState通过参数，把数组的值丢进去
第8章
立即购买按钮可以改为加入购物车等多种需求，所以改为插槽

吸顶效果原理
先获取滚动条的高度
滚动的高度等于组件离顶部的高度时，设置固定定位，top：0
固定定位设置后父容器的宽度和内容区一样所以要更改width为100%

清除视频的默认边框用 object-fit：cover

路由跳转使用$router,路由获取参数使用$route

清除浮动的基本方式

如果res为空则可以赋予一个默认值

关于有些时候样式出现bug如果内部是有js代码做样式调整，可能是js其他代码出错导致样式出现bug这点切记

开发组件的目的一定是复用提高效率

总有些样式是需要使用浮动，哪里使用浮动哪里最好清除下浮动

行高有时候可以不去设置
vbind即@绑定不一定是函数，也可以是变量赋值
./是有提示的
钱的总金额一般是后端进行修改，前端修改安全性不高

css中的优先级问题，h,a标签的优先级高于class所以在设置标签内部的属性比如颜色，字体大小时需要在自身标签中设置，而不是在class中设置

js代码为啥要放在页面底部，原因是防止页面堵塞，要保证页面可以正常渲染，交互放在后面
问题代理不生效
凡是需要做配置的都需要重启服务

退出按钮第一个是把会话清掉，需要和后端链接第二个是把渲染清掉

app.vue只有在第一次进入项目时才会调用
get请求是明文传参，post请求是对象数据流的方式传参
query和params的区别
query是get传参使用方式
path：'/index',
query:{from:'login'}
这时地址栏会拼接地址/index?from=login
params是post传参使用方式
name:‘index，
param：{from:'login'}
可以在控制栏中输入this.$route.params会看到{from:'login'}
跳转路由是使用router获取参数是使用route

什么是会话级别的？
浏览器关闭窗口不是，只有浏览器进程杀掉，才算会话结束


退出流程
先请求后台关闭会话，然后前端需要清理用户名以及购物车数量的渲染 以及把cookie删除
用dispatch清空，JSESSIONID是服务器端给的，登录退出后再次登录发现购物车数量变为了0，也就是说登录成功后需要再次获取购物车的数量，由于页面是单页面的，vuex实际上是存在内存上的，当页面重新刷新时内存会消失，虽然在app.vue里设置了dispatch，但是只有第一次加载页面时才管用，所以需要在navheader上再次调用下，这时会调用购物车数量两次，造成资源浪费，所以需要做判断，如果是从登陆页面跳转过来的就需要调用否则不需要 ，可以使用全局导航守卫，或者做下判断，另外在页面重新没登录加载时是不需要重新调用接口，这时请求报错，这时可以把服务器给的id和本地的id进行同步也就是说，前端接口的优化就是屏蔽掉无用的接口

如果要在控制台查看this.$route.params需要打断点
如何打断点，在项目文件中添加debugger，出现一个灯点击不出错就行
解决两个人同时登陆一个账号删除问题

$emit直接在表达式里写不需要this，但是在函数中需要

删除订单地址流程
点击删除按钮赋值用户行为以及弹窗设置，然后弹窗按下确定后请求接口，请求成功则
关闭弹窗，重新获取地址信息
点·击新增，把用户的
点击框出现不同颜色，就是把当前的索引记录下来，然后绑定class

路由的跳转实现方式有，直接传字符串跳转，第二种使用path路径传参，参数是query
第三种是使用name传参，参数是params

微信扫码支付实际是native支付
微信支付流程
第一步调用接口，拿到服务端返回的字符串，通过qrcode转化为base64字符串图片，不是真实图片地址然后保存图片传给子组件进行渲染，当子组件点关闭时发送关闭事件给父组件
bug
1.请求数据没有报错，用vue devtools没有数据加载到data，应该在mounted中调用下
2.router子路由,页面显示不出来
path不需要添加/
3.方法太多不小心定在methods外边

为什么需要轮循订单状态
订单付款是有时间状态的超过一定时间，订单就会变为关闭状态，所以前端需要隔一点时间请求
bug
从订单确认到订单列表头部信息没有发生改变，而刷新了以后会改变头部信息

接口拦截有两种，一种是接口正常情况下的业务码，一种是http请求错误的状态码

mounted只会渲染一次

没有数据有提示

get请求是有params，post请求没有
如何修改分页器的位置
加一个类选择器在里面添加text-align:center
如何更改分页器内面的颜色
第一种复写里面的样式
第二种自定义主题

要修改居中样式通常可以给一个父标签，设置text-align：center，标签即可居中

部署
放在域名的根目录下用publicPath
打包新目录文件用outputDir
indexpath打印根目录的名字
filenameHashing使生成的静态资源包含hash以便更好的缓存
lintOnSave打开或者关闭eslint
productionSourceMap:false 加快打包构建

图片优化：转化为base64，tinypng网站或者发布到cdn或者七年云，加速服务器，带宽很大且会做缓存，cdn服务器会将图片缓存在cache-control,
15-6服务器url发生什么
域名备案 购买服务器 域名解析

bug如何修改elementUI的样式
在浏览器中打开调试工具点击组件将样式复制保存
然后在自己的文件里修改把scope去掉即可，但是这样有全局污染的风险，需要在根元素上套用一个类名
或者使用深度选择器>>>,在预处理器中不识别要用/deep/替换


bug从订单支付跳转到订单列表，头部组件没有改变样式，刷新后却可以改变
原因是之前使用的是在父组件中定义的动态实现方法，在父组件定义的头部组件在mounted判断中只会渲染一次，跳转只是子路由里的子组件在刷新
解决办法：将头部组件放入子组件中，

bug加入购物车未支付跳转到首页发现购物车有数量但是点开后没有，全部跳转到订单列表里了
解决办法，在订单确认页面点击去结算将购物车数量状态置空保存到vuex中

项目中使用数组的位置和方法
index.vue slice()截取商品数组，不改变原数组
cart.vue filter()过滤选中商品
cart.vue every()购物车下单根据商品数组没有一个选中返回Boolean
orderConfirm.vue map()将商品数组的数量相加
orderList.vue concat()加载更多将商品数组进行连接

小问题1：为什么从vuex中读取的值需要在computed中获取，而不是在data中获取
原因是请求接口保存到vuex中的数据是有延迟的，读取在保存之前就会是空，所以
需要用computed属性来缓存数据，当数据发生变化时重新调用方法。

小问题2：为什么页面刷新后vuex保存的数据比如用户名购物车数量会消失？
原因是store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化
解决办法在app.vue中调用接口获取值保存到vuex中，调用前提是有相应的cookie，根据cookie来调用接口

插槽的监听事件可以在父组件中定义

get请求参数是需要params而put，delete以及post不需要
登录与退出
登录实现的功能有：1.保存userId到cookie中
                 2.保存用户名以及购物车数量到vuex
                 3.跳转到首页
                 4.提示登录成功
退出实现的功能有：1.提示退出成功
                 2.将cookie中的userId置空
                 3.将vuex中的购物车数量以及用户名初始化











